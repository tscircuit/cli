import fs from "node:fs"
import path from "node:path"
import {
  At,
  Footprint,
  KicadPcb,
  parseKicadSexpr,
  FootprintModel,
} from "kicadts"

type KicadProjectSummary = {
  pcbContent: string
  schContent: string
  proContent: string
  outputDir: string
  projectName: string
  sourcePath: string
}

type GenerateKicadFootprintLibraryOptions = {
  projects: KicadProjectSummary[]
  distDir: string
}

const sanitizeLibraryAndFootprintName = (libraryLink?: string) => {
  if (!libraryLink) {
    return {
      libraryName: "generated",
      footprintName: "footprint",
    }
  }

  if (!libraryLink.includes(":")) {
    return {
      libraryName: "generated",
      footprintName: libraryLink.replace(/[\\\/]/g, "-") || "footprint",
    }
  }

  const [rawLibraryName, rawFootprintName] = libraryLink.split(":", 2)
  const libraryName =
    rawLibraryName?.replace(/[\\\/]/g, "-").trim() || "generated"
  const footprintName =
    rawFootprintName?.replace(/[\\\/]/g, "-").trim() || "footprint"

  return {
    libraryName,
    footprintName,
  }
}

const sanitizeFootprint = (
  footprint: Footprint,
  outputLibraryName?: string,
) => {
  const { libraryName, footprintName } = sanitizeLibraryAndFootprintName(
    footprint.libraryLink,
  )

  // Use provided library name or fall back to extracted one
  const targetLibraryName = outputLibraryName || libraryName

  footprint.libraryLink = footprintName
  footprint.position = At.from([0, 0, 0])
  footprint.locked = false
  footprint.placed = false
  footprint.uuid = undefined
  footprint.path = undefined
  footprint.sheetfile = undefined
  footprint.sheetname = undefined
  footprint.properties = []

  const texts = footprint.fpTexts ?? []
  for (const text of texts) {
    text.uuid = undefined
    if (text.type === "reference") {
      text.text = "REF**"
    } else if (text.type === "value" && text.text.trim().length === 0) {
      text.text = footprintName
    }
  }
  footprint.fpTexts = texts

  const pads = footprint.fpPads ?? []
  for (const pad of pads) {
    pad.uuid = undefined
    pad.net = undefined
  }
  footprint.fpPads = pads

  // Handle 3D models - update paths to use library's .3dshapes folder
  const models = footprint.models ?? []
  const updatedModels: FootprintModel[] = []
  const modelFiles: string[] = []

  for (const model of models) {
    if (model.path) {
      // Extract filename from the model path
      const modelFilename = path.basename(model.path)
      // Update path to use the library's .3dshapes folder
      const newPath = `\${KIPRJMOD}/${targetLibraryName}.3dshapes/${modelFilename}`

      const newModel = new FootprintModel(newPath)
      if (model.offset) newModel.offset = model.offset
      if (model.scale) newModel.scale = model.scale
      if (model.rotate) newModel.rotate = model.rotate

      updatedModels.push(newModel)
      modelFiles.push(model.path) // Keep original path for copying
    }
  }
  footprint.models = updatedModels

  return {
    libraryName,
    footprintName,
    content: footprint.getString(),
    modelFiles, // Return original model file paths for copying
  }
}

export const generateKicadFootprintLibrary = async ({
  projects,
  distDir,
}: GenerateKicadFootprintLibraryOptions) => {
  const libraryRoot = path.join(distDir, "kicad-footprints")
  fs.mkdirSync(libraryRoot, { recursive: true })

  type FootprintEntry = {
    libraryName: string
    footprintName: string
    content: string
  }

  const uniqueFootprints = new Map<string, FootprintEntry>()

  for (const project of projects) {
    try {
      const parsed = parseKicadSexpr(project.pcbContent)
      const pcb = parsed.find(
        (node): node is KicadPcb => node instanceof KicadPcb,
      )
      if (!pcb) continue
      const footprints = pcb.footprints ?? []
      for (const footprint of footprints) {
        const sanitized = sanitizeFootprint(footprint)
        const key = `${sanitized.libraryName}::${sanitized.footprintName}`
        if (!uniqueFootprints.has(key)) {
          uniqueFootprints.set(key, sanitized)
        }
      }
    } catch (error) {
      console.warn(
        `Failed to parse KiCad PCB content for footprint extraction from ${project.sourcePath}:`,
        error,
      )
    }
  }

  const libraryNames = new Set<string>()

  for (const entry of uniqueFootprints.values()) {
    libraryNames.add(entry.libraryName)
    const libraryDir = path.join(libraryRoot, `${entry.libraryName}.pretty`)
    fs.mkdirSync(libraryDir, { recursive: true })
    const footprintPath = path.join(
      libraryDir,
      `${entry.footprintName}.kicad_mod`,
    )
    fs.writeFileSync(footprintPath, `${entry.content}\n`)
  }

  if (libraryNames.size > 0) {
    const libTableEntries = Array.from(libraryNames)
      .sort()
      .map(
        (name) =>
          `  (lib (name ${name}) (type KiCad) (uri \${KIPRJMOD}/kicad-footprints/${name}.pretty) (options "") (descr "Generated by tsci build"))`,
      )
    const libTableContent = `(fp_lib_table\n${libTableEntries.join("\n")}\n)\n`
    fs.writeFileSync(path.join(libraryRoot, "fp-lib-table"), libTableContent)
  }
}

export type FootprintEntry = {
  libraryName: string
  footprintName: string
  content: string
  modelFiles?: string[]
}

export const extractFootprintsFromPcb = (
  pcbContent: string,
  outputLibraryName?: string,
): FootprintEntry[] => {
  const uniqueFootprints = new Map<string, FootprintEntry>()

  try {
    const parsed = parseKicadSexpr(pcbContent)
    const pcb = parsed.find(
      (node): node is KicadPcb => node instanceof KicadPcb,
    )
    if (!pcb) return []

    const footprints = pcb.footprints ?? []
    for (const footprint of footprints) {
      const sanitized = sanitizeFootprint(footprint, outputLibraryName)
      const key = `${sanitized.libraryName}::${sanitized.footprintName}`
      if (!uniqueFootprints.has(key)) {
        uniqueFootprints.set(key, {
          libraryName: sanitized.libraryName,
          footprintName: sanitized.footprintName,
          content: sanitized.content,
          modelFiles: sanitized.modelFiles,
        })
      }
    }
  } catch (error) {
    console.warn(
      "Failed to parse KiCad PCB content for footprint extraction:",
      error,
    )
  }

  return Array.from(uniqueFootprints.values())
}
