import fs from "node:fs"
import path from "node:path"
import { At, Footprint, KicadPcb, parseKicadSexpr } from "kicadts"

type KicadProjectSummary = {
  pcbContent: string
  schContent: string
  proContent: string
  outputDir: string
  projectName: string
  sourcePath: string
}

type GenerateKicadFootprintLibraryOptions = {
  projects: KicadProjectSummary[]
  distDir: string
}

const sanitizeLibraryAndFootprintName = (libraryLink?: string) => {
  if (!libraryLink) {
    return {
      libraryName: "generated",
      footprintName: "footprint",
    }
  }

  if (!libraryLink.includes(":")) {
    return {
      libraryName: "generated",
      footprintName: libraryLink.replace(/[\\\/]/g, "-") || "footprint",
    }
  }

  const [rawLibraryName, rawFootprintName] = libraryLink.split(":", 2)
  const libraryName =
    rawLibraryName?.replace(/[\\\/]/g, "-").trim() || "generated"
  const footprintName =
    rawFootprintName?.replace(/[\\\/]/g, "-").trim() || "footprint"

  return {
    libraryName,
    footprintName,
  }
}

const sanitizeFootprint = (footprint: Footprint) => {
  const { libraryName, footprintName } = sanitizeLibraryAndFootprintName(
    footprint.libraryLink,
  )

  footprint.libraryLink = footprintName
  footprint.position = At.from([0, 0, 0])
  footprint.locked = false
  footprint.placed = false
  footprint.uuid = undefined
  footprint.path = undefined
  footprint.sheetfile = undefined
  footprint.sheetname = undefined
  footprint.properties = []

  const texts = footprint.fpTexts ?? []
  for (const text of texts) {
    text.uuid = undefined
    if (text.type === "reference") {
      text.text = "REF**"
    } else if (text.type === "value" && text.text.trim().length === 0) {
      text.text = footprintName
    }
  }
  footprint.fpTexts = texts

  const pads = footprint.fpPads ?? []
  for (const pad of pads) {
    pad.uuid = undefined
    pad.net = undefined
  }
  footprint.fpPads = pads

  return {
    libraryName,
    footprintName,
    content: footprint.getString(),
  }
}

export const generateKicadFootprintLibrary = async ({
  projects,
  distDir,
}: GenerateKicadFootprintLibraryOptions) => {
  const libraryRoot = path.join(distDir, "kicad-footprints")
  fs.mkdirSync(libraryRoot, { recursive: true })

  type FootprintEntry = {
    libraryName: string
    footprintName: string
    content: string
  }

  const uniqueFootprints = new Map<string, FootprintEntry>()

  for (const project of projects) {
    try {
      const parsed = parseKicadSexpr(project.pcbContent)
      const pcb = parsed.find(
        (node): node is KicadPcb => node instanceof KicadPcb,
      )
      if (!pcb) continue
      const footprints = pcb.footprints ?? []
      for (const footprint of footprints) {
        const sanitized = sanitizeFootprint(footprint)
        const key = `${sanitized.libraryName}::${sanitized.footprintName}`
        if (!uniqueFootprints.has(key)) {
          uniqueFootprints.set(key, sanitized)
        }
      }
    } catch (error) {
      console.warn(
        `Failed to parse KiCad PCB content for footprint extraction from ${project.sourcePath}:`,
        error,
      )
    }
  }

  const libraryNames = new Set<string>()

  for (const entry of uniqueFootprints.values()) {
    libraryNames.add(entry.libraryName)
    const libraryDir = path.join(libraryRoot, `${entry.libraryName}.pretty`)
    fs.mkdirSync(libraryDir, { recursive: true })
    const footprintPath = path.join(
      libraryDir,
      `${entry.footprintName}.kicad_mod`,
    )
    fs.writeFileSync(footprintPath, `${entry.content}\n`)
  }

  if (libraryNames.size > 0) {
    const libTableEntries = Array.from(libraryNames)
      .sort()
      .map(
        (name) =>
          `  (lib (name ${name}) (type KiCad) (uri \${KIPRJMOD}/kicad-footprints/${name}.pretty) (options "") (descr "Generated by tsci build"))`,
      )
    const libTableContent = `(fp_lib_table\n${libTableEntries.join("\n")}\n)\n`
    fs.writeFileSync(path.join(libraryRoot, "fp-lib-table"), libTableContent)
  }
}
